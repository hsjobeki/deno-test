import { instantiateWasm, } from "../../../crypto/_wasm_crypto/mod.ts";
import { Buffer } from "../../buffer.ts";
import { Transform } from "../../stream.ts";
import { encode as encodeToHex } from "../../../encoding/hex.ts";
import { encode as encodeToBase64 } from "../../../encoding/base64.ts";
import { encode as encodeToBase64Url } from "../../../encoding/base64url.ts";
import { validateString } from "../validators.mjs";
import { notImplemented } from "../../_utils.ts";
const coerceToBytes = (data) => {
    if (data instanceof Uint8Array) {
        return data;
    }
    else if (typeof data === "string") {
        return new TextEncoder().encode(data);
    }
    else if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
    else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    else {
        throw new TypeError("expected data to be string | BufferSource");
    }
};
export class Hash extends Transform {
    #context;
    constructor(algorithm, _opts) {
        super({
            transform(chunk, _encoding, callback) {
                context.update(coerceToBytes(chunk));
                callback();
            },
            flush(callback) {
                this.push(context.digest(undefined));
                callback();
            },
        });
        if (typeof algorithm === "string") {
            algorithm = algorithm.toUpperCase();
            if (opensslToWebCryptoDigestNames[algorithm]) {
                algorithm = opensslToWebCryptoDigestNames[algorithm];
            }
            this.#context = new (instantiateWasm().DigestContext)(algorithm);
        }
        else {
            this.#context = algorithm;
        }
        const context = this.#context;
    }
    copy() {
        return new Hash(this.#context.clone());
    }
    update(data, _encoding) {
        let bytes;
        if (typeof data === "string") {
            data = new TextEncoder().encode(data);
            bytes = coerceToBytes(data);
        }
        else {
            bytes = coerceToBytes(data);
        }
        this.#context.update(bytes);
        return this;
    }
    digest(encoding) {
        const digest = this.#context.digest(undefined);
        if (encoding === undefined) {
            return Buffer.from(digest);
        }
        switch (encoding) {
            case "hex":
                return new TextDecoder().decode(encodeToHex(new Uint8Array(digest)));
            case "binary":
                return String.fromCharCode(...digest);
            case "base64":
                return encodeToBase64(digest);
            case "base64url":
                return encodeToBase64Url(digest);
            default:
                throw new Error(`The output encoding for hash digest is not implemented: ${encoding}`);
        }
    }
}
export class Hmac extends Transform {
    constructor(hmac, _key, _options) {
        validateString(hmac, "hmac");
        super();
        notImplemented("crypto.Hmac");
    }
    digest(_encoding) {
        notImplemented("crypto.Hmac.prototype.digest");
    }
    update(_data, _inputEncoding) {
        notImplemented("crypto.Hmac.prototype.update");
    }
}
const opensslToWebCryptoDigestNames = {
    BLAKE2B512: "BLAKE2B",
    BLAKE2S256: "BLAKE2S",
    RIPEMD160: "RIPEMD-160",
    RMD160: "RIPEMD-160",
    SHA1: "SHA-1",
    SHA224: "SHA-224",
    SHA256: "SHA-256",
    SHA384: "SHA-384",
    SHA512: "SHA-512",
};
export function createHash(algorithm, opts) {
    return new Hash(algorithm, opts);
}
export default {
    Hash,
    Hmac,
    createHash,
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhhc2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsT0FBTyxFQUdMLGVBQWUsR0FDaEIsTUFBTSxxQ0FBcUMsQ0FBQztBQUM3QyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxNQUFNLElBQUksV0FBVyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDakUsT0FBTyxFQUFFLE1BQU0sSUFBSSxjQUFjLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUN2RSxPQUFPLEVBQUUsTUFBTSxJQUFJLGlCQUFpQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFFN0UsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUlqRCxNQUFNLGFBQWEsR0FBRyxDQUFDLElBQTJCLEVBQWMsRUFBRTtJQUNoRSxJQUFJLElBQUksWUFBWSxVQUFVLEVBQUU7UUFDOUIsT0FBTyxJQUFJLENBQUM7S0FDYjtTQUFNLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBRW5DLE9BQU8sSUFBSSxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDdkM7U0FBTSxJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDbkMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQ3RFO1NBQU0sSUFBSSxJQUFJLFlBQVksV0FBVyxFQUFFO1FBQ3RDLE9BQU8sSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDN0I7U0FBTTtRQUNMLE1BQU0sSUFB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LENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRTdCLEtBQUssRUFBRSxDQUFDO1FBRVIsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFJRCxNQUFNLENBQUMsU0FBZ0M7UUFDckMsY0FBYyxDQUFDLDhCQUE4QixDQUFDLENBQUM7SUFDakQsQ0FBQztJQUlELE1BQU0sQ0FBQyxLQUFpQixFQUFFLGNBQXlCO1FBQ2pELGNBQWMsQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO0lBQ2pELENBQUM7Q0FDRjtBQUtELE1BQU0sNkJBQTZCLEdBQW9DO0lBQ3JFLFVBQVUsRUFBRSxTQUFTO0lBQ3JCLFVBQVUsRUFBRSxTQUFTO0lBQ3JCLFNBQVMsRUFBRSxZQUFZO0lBQ3ZCLE1BQU0sRUFBRSxZQUFZO0lBQ3BCLElBQUksRUFBRSxPQUFPO0lBQ2IsTUFBTSxFQUFFLFNBQVM7SUFDakIsTUFBTSxFQUFFLFNBQVM7SUFDakIsTUFBTSxFQUFFLFNBQVM7SUFDakIsTUFBTSxFQUFFLFNBQVM7Q0FDbEIsQ0FBQztBQU1GLE1BQU0sVUFBVSxVQUFVLENBQUMsU0FBaUIsRUFBRSxJQUF1QjtJQUNuRSxPQUFPLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNuQyxDQUFDO0FBRUQsZUFBZTtJQUNiLElBQUk7SUFDSixJQUFJO0lBQ0osVUFBVTtDQUNYLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDIyIHRoZSBEZW5vIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuXG5pbXBvcnQge1xuICBEaWdlc3RBbGdvcml0aG0sXG4gIERpZ2VzdENvbnRleHQsXG4gIGluc3RhbnRpYXRlV2FzbSxcbn0gZnJvbSBcIi4uLy4uLy4uL2NyeXB0by9fd2FzbV9jcnlwdG8vbW9kLnRzXCI7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiLi4vLi4vYnVmZmVyLnRzXCI7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tIFwiLi4vLi4vc3RyZWFtLnRzXCI7XG5pbXBvcnQgeyBlbmNvZGUgYXMgZW5jb2RlVG9IZXggfSBmcm9tIFwiLi4vLi4vLi4vZW5jb2RpbmcvaGV4LnRzXCI7XG5pbXBvcnQgeyBlbmNvZGUgYXMgZW5jb2RlVG9CYXNlNjQgfSBmcm9tIFwiLi4vLi4vLi4vZW5jb2RpbmcvYmFzZTY0LnRzXCI7XG5pbXBvcnQgeyBlbmNvZGUgYXMgZW5jb2RlVG9CYXNlNjRVcmwgfSBmcm9tIFwiLi4vLi4vLi4vZW5jb2RpbmcvYmFzZTY0dXJsLnRzXCI7XG5pbXBvcnQgdHlwZSB7IFRyYW5zZm9ybU9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vX3N0cmVhbS5kLnRzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZVN0cmluZyB9IGZyb20gXCIuLi92YWxpZGF0b3JzLm1qc1wiO1xuaW1wb3J0IHsgbm90SW1wbGVtZW50ZWQgfSBmcm9tIFwiLi4vLi4vX3V0aWxzLnRzXCI7XG5pbXBvcnQgdHlwZSB7IEJpbmFyeUxpa2UsIEJpbmFyeVRvVGV4dEVuY29kaW5nLCBFbmNvZGluZyB9IGZyb20gXCIuL3R5cGVzLnRzXCI7XG5pbXBvcnQgeyBLZXlPYmplY3QgfSBmcm9tIFwiLi9rZXlzLnRzXCI7XG5cbmNvbnN0IGNvZXJjZVRvQnl0ZXMgPSAoZGF0YTogc3RyaW5nIHwgQnVmZmVyU291cmNlKTogVWludDhBcnJheSA9PiB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgLy8gVGhpcyBhc3N1bWVzIFVURi04LCB3aGljaCBtYXkgbm90IGJlIGNvcnJlY3QuXG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGVkIGRhdGEgdG8gYmUgc3RyaW5nIHwgQnVmZmVyU291cmNlXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBIYXNoIGNsYXNzIGlzIGEgdXRpbGl0eSBmb3IgY3JlYXRpbmcgaGFzaCBkaWdlc3RzIG9mIGRhdGEuIEl0IGNhbiBiZSB1c2VkIGluIG9uZSBvZiB0d28gd2F5czpcbiAqXG4gKiAtIEFzIGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIHdoZXJlIGRhdGEgaXMgd3JpdHRlbiB0byBwcm9kdWNlIGEgY29tcHV0ZWQgaGFzaCBkaWdlc3Qgb24gdGhlIHJlYWRhYmxlIHNpZGUsIG9yXG4gKiAtIFVzaW5nIHRoZSBoYXNoLnVwZGF0ZSgpIGFuZCBoYXNoLmRpZ2VzdCgpIG1ldGhvZHMgdG8gcHJvZHVjZSB0aGUgY29tcHV0ZWQgaGFzaC5cbiAqXG4gKiBUaGUgY3J5cHRvLmNyZWF0ZUhhc2goKSBtZXRob2QgaXMgdXNlZCB0byBjcmVhdGUgSGFzaCBpbnN0YW5jZXMuIEhhc2ggb2JqZWN0cyBhcmUgbm90IHRvIGJlIGNyZWF0ZWQgZGlyZWN0bHkgdXNpbmcgdGhlIG5ldyBrZXl3b3JkLlxuICovXG5leHBvcnQgY2xhc3MgSGFzaCBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICNjb250ZXh0OiBEaWdlc3RDb250ZXh0O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGFsZ29yaXRobTogc3RyaW5nIHwgRGlnZXN0Q29udGV4dCxcbiAgICBfb3B0cz86IFRyYW5zZm9ybU9wdGlvbnMsXG4gICkge1xuICAgIHN1cGVyKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuazogc3RyaW5nLCBfZW5jb2Rpbmc6IHN0cmluZywgY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcbiAgICAgICAgY29udGV4dC51cGRhdGUoY29lcmNlVG9CeXRlcyhjaHVuaykpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSxcbiAgICAgIGZsdXNoKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIHRoaXMucHVzaChjb250ZXh0LmRpZ2VzdCh1bmRlZmluZWQpKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGFsZ29yaXRobSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gTm9kZS9PcGVuU1NMIGFuZCBXZWJDcnlwdG8gZm9ybWF0IHNvbWUgZGlnZXN0IG5hbWVzIGRpZmZlcmVudGx5O1xuICAgICAgLy8gd2UgYXR0ZW1wdCB0byBoYW5kbGUgdGhvc2UgaGVyZS5cbiAgICAgIGFsZ29yaXRobSA9IGFsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKG9wZW5zc2xUb1dlYkNyeXB0b0RpZ2VzdE5hbWVzW2FsZ29yaXRobV0pIHtcbiAgICAgICAgYWxnb3JpdGhtID0gb3BlbnNzbFRvV2ViQ3J5cHRvRGlnZXN0TmFtZXNbYWxnb3JpdGhtXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2NvbnRleHQgPSBuZXcgKGluc3RhbnRpYXRlV2FzbSgpLkRpZ2VzdENvbnRleHQpKFxuICAgICAgICBhbGdvcml0aG0gYXMgRGlnZXN0QWxnb3JpdGhtLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jY29udGV4dCA9IGFsZ29yaXRobTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jY29udGV4dDtcbiAgfVxuXG4gIGNvcHkoKTogSGFzaCB7XG4gICAgcmV0dXJuIG5ldyBIYXNoKHRoaXMuI2NvbnRleHQuY2xvbmUoKSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgaGFzaCBjb250ZW50IHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAqL1xuICB1cGRhdGUoZGF0YTogc3RyaW5nIHwgQXJyYXlCdWZmZXIsIF9lbmNvZGluZz86IHN0cmluZyk6IHRoaXMge1xuICAgIGxldCBieXRlcztcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRhdGEgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSk7XG4gICAgICBieXRlcyA9IGNvZXJjZVRvQnl0ZXMoZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGVzID0gY29lcmNlVG9CeXRlcyhkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLiNjb250ZXh0LnVwZGF0ZShieXRlcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBkaWdlc3Qgb2YgYWxsIG9mIHRoZSBkYXRhLlxuICAgKlxuICAgKiBJZiBlbmNvZGluZyBpcyBwcm92aWRlZCBhIHN0cmluZyB3aWxsIGJlIHJldHVybmVkOyBvdGhlcndpc2UgYSBCdWZmZXIgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIFN1cHBvcnRlZCBlbmNvZGluZ3MgYXJlIGN1cnJlbnRseSAnaGV4JywgJ2JpbmFyeScsICdiYXNlNjQnLCAnYmFzZTY0dXJsJy5cbiAgICovXG4gIGRpZ2VzdChlbmNvZGluZz86IHN0cmluZyk6IEJ1ZmZlciB8IHN0cmluZyB7XG4gICAgY29uc3QgZGlnZXN0ID0gdGhpcy4jY29udGV4dC5kaWdlc3QodW5kZWZpbmVkKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRpZ2VzdCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSBcImhleFwiOlxuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGVuY29kZVRvSGV4KG5ldyBVaW50OEFycmF5KGRpZ2VzdCkpKTtcbiAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uZGlnZXN0KTtcbiAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgcmV0dXJuIGVuY29kZVRvQmFzZTY0KGRpZ2VzdCk7XG4gICAgICBjYXNlIFwiYmFzZTY0dXJsXCI6XG4gICAgICAgIHJldHVybiBlbmNvZGVUb0Jhc2U2NFVybChkaWdlc3QpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUaGUgb3V0cHV0IGVuY29kaW5nIGZvciBoYXNoIGRpZ2VzdCBpcyBub3QgaW1wbGVtZW50ZWQ6ICR7ZW5jb2Rpbmd9YCxcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEhtYWMgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBobWFjOiBzdHJpbmcsXG4gICAgX2tleTogQmluYXJ5TGlrZSB8IEtleU9iamVjdCxcbiAgICBfb3B0aW9ucz86IFRyYW5zZm9ybU9wdGlvbnMsXG4gICkge1xuICAgIHZhbGlkYXRlU3RyaW5nKGhtYWMsIFwiaG1hY1wiKTtcblxuICAgIHN1cGVyKCk7XG5cbiAgICBub3RJbXBsZW1lbnRlZChcImNyeXB0by5IbWFjXCIpO1xuICB9XG5cbiAgZGlnZXN0KCk6IEJ1ZmZlcjtcbiAgZGlnZXN0KGVuY29kaW5nOiBCaW5hcnlUb1RleHRFbmNvZGluZyk6IHN0cmluZztcbiAgZGlnZXN0KF9lbmNvZGluZz86IEJpbmFyeVRvVGV4dEVuY29kaW5nKTogQnVmZmVyIHwgc3RyaW5nIHtcbiAgICBub3RJbXBsZW1lbnRlZChcImNyeXB0by5IbWFjLnByb3RvdHlwZS5kaWdlc3RcIik7XG4gIH1cblxuICB1cGRhdGUoZGF0YTogQmluYXJ5TGlrZSk6IHRoaXM7XG4gIHVwZGF0ZShkYXRhOiBzdHJpbmcsIGlucHV0RW5jb2Rpbmc6IEVuY29kaW5nKTogdGhpcztcbiAgdXBkYXRlKF9kYXRhOiBCaW5hcnlMaWtlLCBfaW5wdXRFbmNvZGluZz86IEVuY29kaW5nKTogdGhpcyB7XG4gICAgbm90SW1wbGVtZW50ZWQoXCJjcnlwdG8uSG1hYy5wcm90b3R5cGUudXBkYXRlXCIpO1xuICB9XG59XG5cbi8qKlxuICogU3VwcG9ydGVkIGRpZ2VzdCBuYW1lcyB0aGF0IE9wZW5TU0wvTm9kZSBhbmQgV2ViQ3J5cHRvIGlkZW50aWZ5IGRpZmZlcmVudGx5LlxuICovXG5jb25zdCBvcGVuc3NsVG9XZWJDcnlwdG9EaWdlc3ROYW1lczogUmVjb3JkPHN0cmluZywgRGlnZXN0QWxnb3JpdGhtPiA9IHtcbiAgQkxBS0UyQjUxMjogXCJCTEFLRTJCXCIsXG4gIEJMQUtFMlMyNTY6IFwiQkxBS0UyU1wiLFxuICBSSVBFTUQxNjA6IFwiUklQRU1ELTE2MFwiLFxuICBSTUQxNjA6IFwiUklQRU1ELTE2MFwiLFxuICBTSEExOiBcIlNIQS0xXCIsXG4gIFNIQTIyNDogXCJTSEEtMjI0XCIsXG4gIFNIQTI1NjogXCJTSEEtMjU2XCIsXG4gIFNIQTM4NDogXCJTSEEtMzg0XCIsXG4gIFNIQTUxMjogXCJTSEEtNTEyXCIsXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBIYXNoIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIGhhc2ggZGlnZXN0c1xuICogdXNpbmcgdGhlIGdpdmVuIGBhbGdvcml0aG1gLiBPcHRpb25hbCBgb3B0aW9uc2AgYXJndW1lbnQgY29udHJvbHMgc3RyZWFtIGJlaGF2aW9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaChhbGdvcml0aG06IHN0cmluZywgb3B0cz86IFRyYW5zZm9ybU9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBIYXNoKGFsZ29yaXRobSwgb3B0cyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSGFzaCxcbiAgSG1hYyxcbiAgY3JlYXRlSGFzaCxcbn07XG4iXX0=